---
title: "APS Data Examples and Derived Variables"
author: "M. Shotwell"
date: "`r Sys.Date()`"
output:
  html_document:
    code_folding: show
    toc: true
---

```{r 'setup and load data', message=FALSE}
knitr::opts_chunk$set(echo = TRUE)

library('ggplot2')
library('dplyr')
library('tidyr')
library('knitr')
library('gt')
library('scales')

## get support functions
source('support_functions.R')

## load data from N=1000 APS cohort
## provides "data", "dictionary" and "codebook" in the working environment
load('20251213_data.RData')
```

# Working with the codebook and dictionary

The codebook shows which forms are collected at which events. For example, the Clinical Frailty Scale is collected at the "Patient/Surrogate Interview" and at each of the 3, 6, and 12 month survey events. The form is not repeating, meaning it can only be completed once per event. Repeating instruments/forms have one row per instance in the data set.

```{r}
codebook %>%
  filter(form_label == 'Clinical Frailty Scale') %>%
  gt()
```

The dictionary gives detailed information about each field. Consider the "frailty_base", which is a radio button field that is part of the Clinical Frailty Scale form. The dictionary gives each possible value for this field. Note that other kinds of fields, notably text fields, may have values that are less structured.

```{r}
dictionary %>%
  filter(field_name == 'frailty_base') %>%
  select('field_name', 'field_type', 'form_label', 'field_label',
    'select_choices_or_calculations', 'branching_logic') %>%
  unclass()
```

You can also use the `view_dict()` function to accomplish the same thing:

```{r}
view_dict('frailty_base', dictionary)
```

Note the branching logic "[frailty_perf] = '1'", which specifies that the "fraily_base" field is only presented in the REDCap user interface when the value of another field [fraily_perf] takes a value '1' for the corresponding record and event. The "frailty_perf" field is used to indicate whether the Clinical Frailty Scale assessment was performed. Thus, "frailty_base" should be missing if "frailty_perf" is "No".

```{r}
view_dict('frailty_perf', dictionary)
```

We can examine whether this is true in the data by cross-tabulating the two fields at the 'Patient/Surrogate Interview' event.

```{r}
data %>%
  ## start with list of record IDs
  filter(!duplicated(record_id)) %>%
  select(record_id) %>%
  ## merge fields from clinical frailty form at the patient/surrogate interview
  left_join(data %>%
    filter(event_label == 'Patient/Surrogate Interview') %>%
    filter(is.na(repeat_instrument)) %>%
    select(record_id, all_of(dictionary %>%
      filter(form_name == 'clinical_frailty_scale') %>%
      pull(field_name))),
    by='record_id') %>%
  xtabs(~ frailty_perf + is.na(frailty_base), data=., addNA=TRUE)
```

Consider the day 0 Confusion Assessment Method (CAM) assessment variable "cam_0". Here the branching logic is more complex involving two other fields. In plain English, the branching logic specifies that the CAM assessment field is only presented in the REDCap interface if the Richmond Agitation-Sedation Scale (RASS) scale was assessed on day 0 (i.e., not missing) and its value was > -4 (values -4 or -5 are non-responsive states).

```{r}
view_dict('cam_0', dictionary)
```

This branching logic can be reproduced to verify that missing values for "cam_0" are due to unsatisfied branching logic:

```{r}
data %>%
  ## start with list of record IDs
  filter(!duplicated(record_id)) %>%
  select(record_id) %>%
  ## merge fields from clinical frailty form at the patient/surrogate interview
  left_join(data %>%
    filter(event_label == 'Daily In-Hospital Forms') %>%
    filter(is.na(repeat_instrument)) %>%
    select(record_id, all_of(dictionary %>%
      filter(form_name == 'sedation_and_delirium_day_2_to_7') %>%
      pull(field_name))),
    by='record_id') %>%
  ## reproduct cam_0 branching logic
  mutate(cam_0_branching_logic =
    ## lowest and highest RASS are documented
    !is.na(highestrass_orres_0) &
    !is.na(lowrass_orres_0) &
    ## at least one is > -4
    (!(lowrass_orres_0 %in% c('-5','-4')) |
     !(highestrass_orres_0 %in% c('-5','-4')))) %>%
  xtabs(~cam_0_branching_logic + is.na(cam_0), data=.)
```

It may be convenient to use numeric codes for multiple choice fields instead of the value labels. The code below creates a data frame that maps the label to numeric code for a multiple choice field:

```{r}
## show label-to-code map for 'elig_vent_support'
## get_code_label_map defined in support_functions.R
get_code_label_map('elig_vent_support', dictionary) %>%
  select(elig_vent_support, elig_vent_support_code) %>%
  gt()
```

The numeric codes that then be easily merged with the data:

```{r}
## join codes for 'elig_vent_support' variable
data %>%
  ## merge codes for 'elig_vent_support'
  left_join(
    get_code_label_map('elig_vent_support', dictionary),
    by='elig_vent_support') %>%
  ## show first few rows at the relevant event
  filter(event_label == 'Pre-Enrollment') %>%
  filter(is.na(repeat_instrument)) %>%
  select(record_id, elig_vent_support, elig_vent_support_code) %>%
  head() %>%
  gt()
```

If you don't know which `event_label` a particular data value is associated with (i.e., what to filter for), use the support function `view_label()`:

```{r}
view_label(data, ards_clinical_judgement)
```

# Table of syndrome adjudications

The code below creates a data frame with one record per participant with the consensus syndrome adjudication data for that participant.

```{r}
## get the field names from the syndrome adjudication form
syndrome_fields <- dictionary %>%
  filter(form_label == 'Syndrome Adjudication (Investigators Form) [day -2 to 7]') %>%
  pull(field_name)

syndrome_data <- data %>%
  ## filter to the relevant event
  filter(event_label == 'Syndrome Adjudication') %>%
  ## make sure you dont get repeating instrument rows
  filter(is.na(repeat_instrument)) %>%
  ## get ID fields and syndrome adjudication fields
  select(record_id, event_label, enrolling_center, all_of(syndrome_fields)) %>%
  ## make sure there is one record per participant, even if no adjudication row
  right_join(data %>% select(record_id) %>% filter(!duplicated(record_id)),
    by='record_id')

## show a portion of the table
syndrome_data %>%
  select(record_id, ards_clinical_judgement,
    pna_clinical_judgement, sepsis_clinical_judgement) %>%
  head() %>%
  gt()
```

# Derived variables

## SOFA-2 scores

The code below converts the required data fields in wide format to long, computes each component of the SOFA-2 score, and creates a figure to display them. In general, the criteria listed in in [Ranzani et al; 2025](https://jamanetwork.com/journals/jama/fullarticle/2840822), specifically Table 2 and its footnotes, were used to code the SOFA-2 component scores. The algorihms for each component are listed below, including any deviations from the recommended approach.

### Brain

The Glasgow Coma Score (GCS) measured closest to 8am was used to calculate the Brain SOFA-2 component. In APS, the verbal component of GCS is assigned a value of 1 (no verbal response; worst score) for participants who are intubated, and the GCS total score is appended with the character 'L' (e.g., '8L'). However, to compute the SOFA-2 Brain component, participants who were intubated are assigned a verbal score of 5 (orientated to person, place, and time; best score). For example, '8L' would be treated as 12 = 8 + 4. The GCS criteria were then applied as described in Table 2 of [Ranzani et al; 2025](https://jamanetwork.com/journals/jama/fullarticle/2840822). If a GCS is recorded, that value is used regardless of sedative medication use (this may partially in conflict with footnote c). Since in APS the GCS component scores are not recorded individually, it is not possible to impute the GCS from a subset of its component scores (see footnote d). In APS, there is no reliable way to know if a medication was used to treat delirium. Thus, no modification is made for drug treatment for delirium (see footnote e). If the Brain component is missing (as a result of missing or 'not documented' GCS), then the rules for imputing missing values (described below) apply.

### Respiratory

The PaO2/FiO2 and SpO2/FiO2 ratios, and the corresponding levels of respiratory support are calculated using measurements taken at the lowest PaO2 or SpO2 on that day, respectively. FiO2 is treated as missing (and thus PaO2/FiO2 and SpO2/FiO2 ratios are also treated as missing) if the participant was receiving ECMO without invasive mechanical ventilation at the time of FiO2 measurement. If the participant was on room air or receiving supplemental oxygen by nasal cannula, FiO2 was calculated using the following formula: FiO2 = min(0.21 + 0.03 * LPM, 1), where LPM is liters per minute on nasal cannula or 0 if on room air. SpO2/FiO2 is treated as missing if the SpO2 was >97% at the time of FiO2 measurement. If the P/F ratio was not missing, the P/F ratio and corresponding ventilatory support at the time of measurement were used to evaluate the Respiratory SOFA criteria described in Table 2 of [Ranzani et al; 2025](https://jamanetwork.com/journals/jama/fullarticle/2840822). If the P/F ratio was missing, the S/F ratio and corresponding ventilatory support were used instead with alternative thresholds as described in footnote f. The following were considered advanced ventilatory support: ECMO and IMV, IMV without ECMO, NIV, HFNO (high flow nasal oxygen), consistent with footnote g. The following were not considered advanced ventilatory support: ECMO without IMV, standard flow supplemental oxygen, and no respiratory support or supplemental oxygen (spontaneously breathing room air). If advanced ventilatory support was not available, only the P/F or S/F criteria were considered, consistent with footnote h. ECMO with or without IMV was assigned a Respiratory SOFA score of 4, consistent with footnote i. If the Respiratory component is missing (as a result of missing both P/F and S/F ratios and no evidence of ECMO), then the rules for imputing missing values (described below) apply.

### Cardiovascular

Measurements taken closest to 8am were used to evaluate the Cardiovascular SOFA-2 component. MAP was calculated using the following formula: MAP = 1/3 * SBP + 2/3 * DBP. Infusion rates for the following vasopressors/inotropes, at the time the blood pressure values closest to 8am were measured, were used to evaluate the vasopressor/inotrop criteria described in Table 2 of [Ranzani et al; 2025](https://jamanetwork.com/journals/jama/fullarticle/2840822): norepinephrine, epinephrine, phenylephrine, vasopressin, dopamine, dobutamine, and angiotensin II. Milrinone was not used. Infusion rates reported in mcg/min were converted to mcg/kg/min by dividing participant body weight (in kg) measured closest to hospital arrival. ECMO with or without IMV was considered mechanical support, consistent with footnote i and n. No other types of cardiovascular mechanical support are recorded in APS. All reported vasopressor doses are assumed to satisfy the requirements listed in footnotes j, k, and m, but there is insufficient information collected as part of APS to verify these requirements. If dopamine is the only vasopressor used, alternative criteria are used, consistent with footnote l. Missing vasopressor infusion rates are assumed to equivalent to zero. If the Cardiovascular component is missing (as a result of missing SBP or DBP, and thus missing MAP), then the rules for imputing missing values (described below) apply.

### Liver

Total bilirubin measured closest to 8am was used to evaluate the Liver SOFA-2 component using the thresholds listed in Table 2 of [Ranzani et al; 2025](https://jamanetwork.com/journals/jama/fullarticle/2840822). If the Liver component is missing (as a result of missing total bilirubin), then the rules for imputing missing values (described below) apply.

### Kidney

Creatinine measured closest to 8am was used to evaluate the Renal SOFA-2 component using the thresholds listed in Table 2 of [Ranzani et al; 2025](https://jamanetwork.com/journals/jama/fullarticle/2840822). Although urine output (UOP) information is collected on days -2 through 3, the UOP criteria are ignored for the following reasons: 1) lack of UOP data on days 4-7 makes it impossible to apply consistent criteria across all study days between -2 and 7; 2) clinically collected UOP data in APS are not considered sufficiently accurate to assess kidney dysfunction. Participants with chronic or new (during hospitalization, regardless of indication, which may conflict with footnote o) kidney replacement therapy were scored 4 on the Kidney SOFA-2 component for all days between and including the days RRT was initiated and when the participant was finally liberated from RRT, consistent with footnote q. There is insufficient information collected in APS to evaluate whether participants meet criteria for RRT among those who are not receiving RRT (see footnote p). If the Kidney component is missing (as a result of missing creatinine and no evidence of chronic or new RRT), then the rules for imputing missing values (described below) apply.

### Hemostasis

Platelet count closest to 8am was used to evaluate the Hemostasis SOFA-2 component using the thresholds listed in Table 2 of [Ranzani et al; 2025](https://jamanetwork.com/journals/jama/fullarticle/2840822). If the Hemostasis component is missing (as a result of missing platelet count), then the rules for imputing missing values (described below) apply.

### Handling of missing values

The rules below for handling missing values will be applied in order from first to last, with earlier rules taking priority, and subsequent rules taking effect for values that remain missing.

1. For participants that are not hospitalized or not actively enrolled (e.g., withdrawn or discontinued with no further data collection) on a given study day, the SOFA-2 component and total scores are considered unmeasured and not handled further.

2. For each component score, the earliest missing score among study days -2, -1, or 0 is assigned a value of 0 (normal), consistent with footnote b in [Ranzani et al; 2025](https://jamanetwork.com/journals/jama/fullarticle/2840822).

3. Last observation carry forward (LOCF) is used to impute missing component scores, consistent see footnote b in [Ranzani et al; 2025](https://jamanetwork.com/journals/jama/fullarticle/2840822).

```{r 'sofa scores', fold=TRUE}

## daily in-hospital measurements needed for SOFA are all collected at the
## 'Daily In-Hospital Forms' event. Each day has a separate set of fields,
## e.g., daily_pa02_lowest_m2, daily_pa02_lowest_m1, daily_pa02_lowest_0, ...
## which correspond to daily lowest PaO2 on day -2, -1, 0, ...

## isolate the daily in-hospital data
data_sofa <- data %>%

  ## filter to the relevant event
  filter(event_label == 'Daily In-Hospital Forms') %>%

  ## filter out any repeat instrument rows (none of the SOFA variables are
  ## on a repeating instrument/form)
  filter(is.na(repeat_instrument)) %>%
  
  ## merge data from the "Day 0" event
  select(-m_weight_kg, -enrollment_time, -sofa_base_renal_chronic) %>%
  left_join(data %>%
    filter(event_label == 'Day 0') %>%
    select(record_id, m_weight_kg, enrollment_time,
      sofa_base_renal_chronic),
    by='record_id') %>%
  
  ## merge data from the "Hospital Discharge and Summary" event
  select(-rrt_stdat, -rrt_endat) %>%
  left_join(data %>%
    filter(event_label == "Hospital Discharge and Summary") %>%
    filter(is.na(repeat_instrument)) %>%
    select(record_id, rrt_stdat, rrt_endat),
    by='record_id') %>%

  ## ensure there is exactly one row per participant; this is good practice
  ## because some participants will not have any records for some events; this
  ## ensures that there is a data point for each participant, even if that data
  ## point is NA
  right_join(data %>%
    filter(!duplicated(record_id)) %>%
    select(record_id),
    by='record_id') %>%

  ## select variables involved in SOFA calculations
  select(
    record_id,
    m_weight_kg,
    enrollment_time,
    rrt_stdat,
    rrt_endat,
    ## respiratory
    matches('daily_pa02_lowest_(m2|m1|[0-7])'),
    matches('daily_resp_lowest_pao2_(m2|m1|[0-7])'),
    matches('daily_fio2_lowest_pao2_(m2|m1|[0-7])'),
    matches('daily_o2_lowest_pao2_(m2|m1|[0-7])'),
    matches('daily_spo2_lowest_(m2|m1|[0-7])'),
    matches('daily_resp_lowest_(m2|m1|[0-7])'),
    matches('daily_fio2_lowest_(m2|m1|[0-7])'),
    matches('daily_o2_lowest_(m2|m1|[0-7])'),
    ## coagulation
    matches('daily_platelet_8a_(m2|m1|[0-7])'),
    ## liver
    matches('daily_tbili_8a_(m2|m1|[0-7])'),
    ## cardiovascular
    matches('daily_sbp_8a_(m2|m1|[0-7])'),
    matches('daily_dbp_8a_(m2|m1|[0-7])'),
    matches('daily_dopa_dose_8a_(m2|m1|[0-7])_(mcg|mcgkg)'),
    matches('daily_dopa_dos_8a_(m2|m1|[0-7])_(mcg|mcgkg)'),
    matches('daily_dobuta_8a_(m2|m1|[0-7])_(mcg|mcgkg)'),
    matches('daily_epi_dose_8a_(m2|m1|[0-7])_(mcg|mcgkg)'),
    matches('daily_ne_dose_8a_(m2|m1|[0-7])_(mcg|mcgkg)'),
    matches('daily_ang2_8a_(m2|m1|[0-7])_(mcg|mcgkg)'),
    matches('daily_phen_dos(e)?_8a_(m2|m1|[0-7])_(mcg|mcgkg)'),
    matches('daily_vaso_dose_8a_(m2|m1|[0-7])'),
    matches('daily_resp_8a_(m2|m1|[0-7])'),
    ## CNS
    matches('daily_gcs_8a_(m2|m1|[0-7])'),
    ## Renal
    sofa_base_renal_chronic,
    matches('daily_cr_8a_(m2|m1|[0-7])')) %>%

  ## rename the columns so that the study day is always the last element
  rename_with(~sub('(.+)_(m2|m1|[0-7])_(.+)', '\\1_\\3_\\2', x=.)) %>%

  ## pivot from wide to long with respect to days -2, -1, 0, ..., 7
  pivot_longer(
    ## pivot all columns except these
    cols = -c(record_id, m_weight_kg,
      enrollment_time, rrt_stdat, rrt_endat,
      sofa_base_renal_chronic),
    names_to = c('.value', 'study_day'),
    names_pattern = '(.+)_(m2|m1|[0-7])') %>%

  ## convert study_day to numeric
  mutate(study_day = as.numeric(sub('m', '-', study_day))) %>%
  
  ## respiratory
  mutate(pf_ratio = calc_pf_ratio(
    low_pao2 = daily_pa02_lowest,
    resp_low_pao2 = daily_resp_lowest_pao2,
    fio2_low_pao2 = daily_fio2_lowest_pao2,
    o2_low_pao2 = daily_o2_lowest_pao2)) %>%
  mutate(sf_ratio = calc_sf_ratio(
    low_spo2 = daily_spo2_lowest,
    resp_low_spo2 = daily_resp_lowest,
    fio2_low_spo2 = daily_fio2_lowest,
    o2_low_spo2 = daily_o2_lowest)) %>%
  mutate(sofa_resp = calc_sofa_resp(
    pf_ratio = pf_ratio,
    sf_ratio = sf_ratio)) %>%
  mutate(sofa_2_resp = calc_sofa_2_resp(
    pf_ratio = pf_ratio,
    sf_ratio = sf_ratio,
    resp_low_pao2 = daily_resp_lowest_pao2,
    resp_low_spo2 = daily_resp_lowest)) %>%
  
  ## coagulation
  mutate(sofa_coag   = calc_sofa_coag(platelets = daily_platelet_8a)) %>%
  mutate(sofa_2_coag = calc_sofa_2_coag(platelets = daily_platelet_8a)) %>%

  ## liver
  mutate(sofa_livr   = calc_sofa_livr(bilirubin = daily_tbili_8a)) %>%
  mutate(sofa_2_livr = calc_sofa_2_livr(bilirubin = daily_tbili_8a)) %>%

  ## cardiovascular
  mutate(sofa_card = calc_sofa_card(
    sbp = daily_sbp_8a,
    dbp = daily_sbp_8a,
    dopa_mcg = daily_dopa_dose_8a_mcg,
    dopa_mcgkg = daily_dopa_dos_8a_mcgkg,
    dobu_mcg = daily_dobuta_8a_mcg,
    dobu_mcgkg = daily_dobuta_8a_mcgkg,
    epin_mcg = daily_epi_dose_8a_mcg,
    epin_mcgkg = daily_epi_dose_8a_mcgkg,
    nore_mcg = daily_ne_dose_8a_mcg,
    nore_mcgkg = daily_ne_dose_8a_mcgkg,
    weight_kg = m_weight_kg)) %>%
  mutate(sofa_2_card = calc_sofa_2_card(
    sbp = daily_sbp_8a,
    dbp = daily_sbp_8a,
    dopa_mcg = daily_dopa_dose_8a_mcg,
    dopa_mcgkg = daily_dopa_dos_8a_mcgkg,
    dobu_mcg = daily_dobuta_8a_mcg,
    dobu_mcgkg = daily_dobuta_8a_mcgkg,
    epin_mcg = daily_epi_dose_8a_mcg,
    epin_mcgkg = daily_epi_dose_8a_mcgkg,
    nore_mcg = daily_ne_dose_8a_mcg,
    nore_mcgkg = daily_ne_dose_8a_mcgkg,
    phen_mcg = daily_phen_dose_8a_mcg,
    phen_mcgkg = daily_phen_dos_8a_mcgkg,
    vaso_dose = daily_vaso_dose_8a,
    ang2_mcg = daily_ang2_8a_mcg,
    ang2_mcgkg = daily_ang2_8a_mcgkg,
    weight_kg = m_weight_kg,
    resp_supp = daily_resp_8a)) %>%
  
  ## CNS
  ## calculate wither 'T' present in GCS; indicating intubated patient
  mutate(sofa_cns_gcs_t = ifelse(is.na(daily_gcs_8a), NA, grepl('T', daily_gcs_8a))) %>%
  ## create variable where GCS with a 'T' are set to NA
  mutate(sofa_cns_gcs_no_t = as.numeric(daily_gcs_8a)) %>%
  mutate(sofa_cns   = calc_sofa_cns(gcs = daily_gcs_8a)) %>%
  mutate(sofa_2_cns = calc_sofa_2_cns(gcs = daily_gcs_8a)) %>%

  ## Renal
  ## calculate chronic or new RRT status
  mutate(
    rrt_stdat = as.Date(rrt_stdat),
    rrt_endat = as.Date(rrt_endat),
    enrollment_date = as.Date(enrollment_time)) %>%
  mutate(chronic_or_new_rrt = case_when(
    grepl("Chronic kidney replacement therapy", sofa_base_renal_chronic) ~ TRUE,
    (study_day >= as.numeric(rrt_stdat - enrollment_date)) &
    (is.na(rrt_endat) | study_day <= as.numeric(rrt_endat - enrollment_date)) ~ TRUE,
    TRUE ~ FALSE
  )) %>%
  mutate(sofa_rena   = calc_sofa_rena(daily_cr_8a)) %>%
  mutate(sofa_2_rena = calc_sofa_2_rena(daily_cr_8a, rrt = chronic_or_new_rrt)) %>%
  
  ## Total SOFA
  mutate(sofa_totl   = sofa_resp + sofa_coag + sofa_livr + sofa_card + sofa_cns + sofa_rena) %>%
  mutate(sofa_2_totl = sofa_2_resp + sofa_2_coag + sofa_2_livr + sofa_2_card + sofa_2_cns + sofa_2_rena) %>%

  ## get death and status information
  left_join(data %>%
    filter(event_label == 'Logs', is.na(repeat_instrument)) %>%
    select(record_id, dthind, dthdat, dsdecod, dsstdat),
    by='record_id') %>%
  
  ## get discharge categories and ICU admission dates
  left_join(data %>%
    filter(event_label == 'Hospital Discharge and Summary', is.na(repeat_instrument)) %>%
    select(record_id, disdat, icu_occur, icu_stdat, icu_endat, icu_discat),
    by='record_id') %>%
  
  ## get hospital arrival date and enrollment time
  left_join(data %>%
    filter(event_label == 'Day 0', is.na(repeat_instrument)) %>%
    select(record_id, ds_arrival_date),
    by='record_id') %>%
  
  ## calculate study days for death and ICU admission dates
  mutate(death_day = as.numeric(difftime(as.Date(dthdat), as.Date(enrollment_time), units='days'))) %>%
  mutate(icu_start_day= as.numeric(difftime(as.Date(icu_stdat), as.Date(enrollment_time), units='days'))) %>%
  mutate(icu_end_day= as.numeric(difftime(as.Date(icu_endat), as.Date(enrollment_time), units='days'))) %>%
  
  ## calculate whether all SOFA components are missing
  mutate(sofa_all_na = if_all(all_of(
    paste0('sofa_', c('resp','coag','livr','card','cns','rena'))), is.na)) %>%
  mutate(sofa_2_all_na = if_all(all_of(
    paste0('sofa_2_', c('resp','coag','livr','card','cns','rena'))), is.na)) %>%

  ## calculate study date for each study day
  mutate(study_date = as.difftime(study_day, units='days') + as.Date(enrollment_time)) %>%
  
  ## get reasons for missing SOFA scores; note that even if one of these reasons
  ## is present, there may still be a SOFA score for that day (e.g., if a SOFA score
  ## was measured on the same day as hospital discharge).
  mutate(sofa_2_missing_reason = case_when(
    study_date < as.Date(ds_arrival_date) ~ "Pre-hospital",
    !is.na(dthdat) & study_date > as.Date(dthdat) ~ "Deceased",
    !is.na(disdat) & study_date > as.Date(disdat) ~ "Discharged",
    !is.na(dsstdat) & study_date > as.Date(dsstdat) &
      grepl('Withdrawn|Lost|No further', dsdecod) ~ dsdecod,
    TRUE ~ NA)) %>%
  
  ## indicate which SOFA scores are eligible for imputation
  mutate(sofa_2_impute_eligible = is.na(sofa_2_totl) &
    is.na(sofa_2_missing_reason)) %>%
  
  ## ## impute "normal" for first impute-eligible missing value among days -2:0, 
  ## then use LOCF for remaining impute-eligible missing values
  arrange(record_id, study_day) %>%
  group_by(record_id) %>%
  mutate(across(all_of(paste0('sofa_2_', c('resp','coag','livr','card','cns','rena'))),
    .fns = ~calc_sofa_2_impute(., sofa_2_impute_eligible, study_day),
    .names = "{.col}_impu")) %>%
  ungroup() %>%
  
  ## compute imputed total score
  mutate(sofa_2_totl_impu = sofa_2_resp_impu + sofa_2_coag_impu + 
    sofa_2_livr_impu + sofa_2_card_impu + sofa_2_cns_impu + sofa_2_rena_impu)
  
  # select(record_id, study_day, 
  #   starts_with('sofa_2'),
  #   icu_start_day, icu_end_day, death_day)
```

### Plot of component scores
```{r fold=TRUE}
data_sofa %>%
  select(record_id, study_day, matches('sofa_2_.+_impu')) %>%
  select(-sofa_2_totl_impu) %>%
  pivot_longer(cols = starts_with('sofa'), names_to = 'component') %>% 
  mutate(study_day = factor(study_day, levels=-2:7)) %>%
  mutate(value = factor(value)) %>%
  mutate(component = case_match(component,
    "sofa_2_resp_impu" ~ "Respiratory",
    "sofa_2_coag_impu" ~ "Coagulation",
    "sofa_2_livr_impu" ~ "Liver",
    "sofa_2_card_impu" ~ "Cardiovascular",
    "sofa_2_cns_impu" ~ "CNS",
    "sofa_2_rena_impu" ~ "Renal")) %>%
  group_by(study_day, component, value) %>%
  summarise(count = n(), .groups='drop') %>%
  ggplot(aes(x=study_day, y=count, fill=value)) +
    geom_bar(stat="identity", position='stack') +
    facet_wrap(~component) +
  labs(x='Study Day', y='Participant Count', fill='Score', title='SOFA-2 Component Scores')
```

### Plot of total scores

```{r fold=TRUE}
data_sofa %>%
  select(record_id, study_day, sofa_2_totl_impu) %>%
  mutate(study_day = factor(study_day, levels=-2:7)) %>%
  mutate(sofa_2_totl_impu = cut(sofa_2_totl_impu, breaks=c(-Inf, 1, 6, 9, 12, Inf), 
    labels=c('0-1 Normal', '2-6 Mild', '7-9 Moderate', '10-12 Severe', '>12 Very Severe'))) %>%
  #mutate(sofa_2_totl_imp = factor(sofa_2_totl_imp)) %>%
  group_by(study_day, sofa_2_totl_impu) %>%
  summarise(count = n(), .groups='drop') %>%
  ggplot(aes(x=study_day, y=count, fill=sofa_2_totl_impu)) +
    geom_bar(stat="identity", position='stack') +
    labs(x='Study Day', y='Participant Count', fill='Score', title='SOFA-2 Total Score')
```

### Plot of reasons for missing scores

```{r fold=TRUE}
data_sofa %>%
  select(record_id, study_day, sofa_2_missing_reason) %>%
  mutate(study_day = factor(study_day, levels=-2:7)) %>%
  rename(sofa_missing_reason = sofa_2_missing_reason) %>%
  mutate(sofa_missing_reason =
    ifelse(is.na(sofa_missing_reason), 'Not missing', sofa_missing_reason)) %>%
  mutate(sofa_missing_reason = factor(sofa_missing_reason, levels=c(
    "Pre-hospital", "Discharged", "Deceased",
    "Discontinued - No further data collection", "Other",
    "Not missing"))) %>%
  group_by(study_day, sofa_missing_reason) %>%
  summarise(count = n(), .groups='drop') %>%
  ggplot(aes(x=study_day, y=count, fill=sofa_missing_reason)) +
    geom_bar(stat="identity", position='stack') +
    labs(x='Study Day', y='Participant Count', fill='Reason', title='SOFA-2 Missing Reason') +
    scale_fill_manual(values = c(hue_pal()(5), "grey70")) +
    theme_light()
```


## APS Aim 6 Steroid DAG Variables

```{r}
## Filter the excluded record to keep variable summaries clean
data_filtered <- data |> filter(record_id != '52-0023')

# Source variable derivation code
source("R/steroid-dag-variables.R")

# Calculate steroid DAG variables
steroid_dag_data <- calc_all_steroid_dag_variables(data_filtered, dictionary)

# Example: Get distribution of sys_delirium_0 variable
steroid_dag_data |>
  group_by(sys_delirium_0) |>
  summarise(count = n()) |>
  mutate(percent = round(count / sum(count) * 100, 2)) |>
  gt()

# Example: Using support function to display count table for a variable
steroid_dag_data |>
  display_grand_total(sys_active_covid19_0)
```
